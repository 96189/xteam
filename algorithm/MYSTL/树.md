
线性序列由于按顺序访问
二分查找可将线性序列的效率优化到最好情况O(log(n)),其余的查找算法必将按顺序访问查找的效率最坏为O(n)

树型结构(半线性结构)
只考虑二叉树
最好最坏的查找复杂度都为(log(n))

## AVL树
    严格的平衡树 以左右子树高度差(平衡因子) 范围[-1,-1] 衡量是否平衡,每次插入和删除通过重平衡算法对局部调整
## 效率
    插入和删除的效率平均为O(log(n))
### 缺陷
    插入和删除过程中带来的调整次数会有较大的不平衡 最坏情况插入调整O(1)次即可 删除需要调整O(log(n))

## 伸展树
    分摊意义上的高效率平均为O(log(n))
    最好情况下为O(log(k))
    假设数据集规模为n 经常访问的数据集为k 访问次数为m 三者关系为 m >> n >> k
    则一次访问的最好效率为O(log(k)) 
### 数据访问
#### 数据操作的理想情况:
        所有操作彼此独立 次序随机且概率相等
#### 数据操作的真实情况:
        数据操作之前有很强的关联性
        局部性原理:1、刚刚访问过的元素 极有可能在不久之后再次被访问 2、即将被访问的下一个元素 就有可能就处于不久之前访问过
    的某个元素的附近
### 伸展树的目标
    伸展树 将刚被访问过的节点及时的转移至树根附近,加速后序操作.

### 伸展效率
#### 逐层伸展的效率
    n次操作需要的总旋转次数为 (n-1) + (n-2) + (n-3) + ... +1 = n^2 平均效率为n^2/n=n
#### 双层伸展的效率
    由于双层伸展每次会将树高度降低一半 因此分摊成本为O(log(n))

### 伸展树的局限性
    由于伸展树依赖于局部性 如果整个数据访问是随机化的 则不合适 会造成大量的调整操作 不适合敏感场景
    
## B-树
### 定义
    二叉搜索树的n路归并,因此B-树中序遍历也是有序的

### 特点:
    由于节点存在多个孩子指针 因此整棵树 整体上更宽 更矮 因此log(h)更小
    上层节点到下层节点的访问相当于一次IO操作
    节点中保存多个关键码 按照向量的存储方式进行组织
    本质上B-树是向量和二叉搜索树的结合 通过树形结构将 向量组织起来 树形结构搜索每次排除掉一半 向量可存储更多的数据 减少树的元数据

### 树结构
    阶次限定树的分支数,m个关键码对应的阶次上下界限为[m/2取上整, m+1]
    树节点:
        父节点
        关键码向量:有序的关键码向量(可调用一些有序序列的算法)
        孩子向量:存储子树的指针

### 插入和删除操作
        B-树阶次到达下界时(下溢)需要旋转或者合并操作 可能使树高降低一层 最多执行h次 h=log(n)
        到达上界(上溢)时需要分裂 可能使树高升高一层 最多执行h次 h=log(n)