
线性序列由于按顺序访问
二分查找可将线性序列的效率优化到最好情况O(log(n)),其余的查找算法必将按顺序访问查找的效率最坏为O(n)

树型结构(半线性结构)
只考虑二叉树
最好最坏的查找复杂度都为(log(n))

## AVL树
    严格的平衡树 以左右子树高度差(平衡因子) 范围[-1,-1] 衡量是否平衡,每次插入和删除通过重平衡算法对局部调整
## 效率
    插入和删除的效率平均为O(log(n))
### 缺陷
    插入和删除过程中带来的调整次数会有较大的不平衡 最坏情况插入调整O(1)次即可 删除需要调整O(log(n))

## 伸展树
    分摊意义上的高效率平均为O(log(n))
    最好情况下为O(log(k))
    假设数据集规模为n 经常访问的数据集为k 访问次数为m 三者关系为 m >> n >> k
    则一次访问的最好效率为O(log(k)) 
### 数据访问
#### 数据操作的理想情况:
        所有操作彼此独立 次序随机且概率相等
#### 数据操作的真实情况:
        数据操作之前有很强的关联性
        局部性原理:1、刚刚访问过的元素 极有可能在不久之后再次被访问 2、即将被访问的下一个元素 就有可能就处于不久之前访问过
    的某个元素的附近
### 伸展树的目标
    伸展树 将刚被访问过的节点及时的转移至树根附近,加速后序操作.

### 伸展效率
#### 逐层伸展的效率
    n次操作需要的总旋转次数为 (n-1) + (n-2) + (n-3) + ... +1 = n^2 平均效率为n^2/n=n
#### 双层伸展的效率
    由于双层伸展每次会将树高度降低一半 因此分摊成本为O(log(n))

### 伸展树的局限性
    由于伸展树依赖于局部性 如果整个数据访问是随机化的 则不合适 会造成大量的调整操作 不适合敏感场景
    
