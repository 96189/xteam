
## 排序算法
### bubbleSort的优化
### bubbleSort最好、最坏、平均时间复杂度分析

### insertionSort的优化
### insertionSort最好、最坏、平均时间复杂度分析

### selectionSort的优化
### selectionSort最好、最坏、平均时间复杂度分析

### mergeSort
    quickSort的关键在于合,每次需要合并左右的序列为一个整体
### mergeSort最好、最坏、平均时间复杂度分析
### mergeSort的空间复杂度

### quickSort
    quickSort的关键在于分,每次确定数据data[i]其在序列中的最终位置,共需要n次确定每个数据的最终位置
* 算法的不变性与单调性
    轴点构造算法 使序列满足 max(SL) <= pivotVal <= min(SR)

* 分治策略
    * 规模减小  
        假设数据规模为S 则分治策略将数据分为 S = SL + SR
    * 各部分独立  
        分割后的序列依然满足不变性与单调性

### quickSort
* LUG轴点划分算法
    |          |          |          |
         L           U          G
    s                                e

    整个序列范围为[s, e] pivot = val[s]

    算法不变性 L <= U <= G
    初始状态
        U [s, e]
    划分过程
        while (pivot <= val[e]) --e // 扩展G的范围 压缩U的范围
        val[s] = val[e]             // 保持不变性 s保存较小的值 空出e位置

        while (val[s] <= pivot) ++e // 扩展L的范围 压缩U的范围
        val[e] = val[s]             // 保持不变性 e保存较大的值 空出s位置

    结束状态
        s == e // U的范围被压缩为空
        pivot最终应该被放置的位置

* LGU轴点划分算法
    |pivot|          |          |          |
    lo                m          k          hi
    
    L [lo + 1, m)
    G [m, k)
    U [k, hi)

    算法不变性 L < val[m] <= G
    初始状态 
        U 为除pivot以外的所有值集合 则k = lo + 1
        L G为空集 则m = lo
    划分过程
        若pivot <= U[k] 则++k相当于G增长
        否则 swap(L[++m],U[k]) 相当于L增长
    最终状态
        |pivot|               |              |
                               m
        swap(pivot, G[m]) // 此处pivot为引用类型

* 最好情况
    数组足够随机(无序) 每次轴点构造算法选择的轴点恰好为序列重点 将序列二等分 时间复杂度为 n * log n
* 最坏情况
    数据已基本有序 每次轴点构造算法选择的轴点恰好为序列的极值未能将序列分为L R 时间复杂度为 n * n
* quickSort优化的关键
    轴点的选择 尽量保证不取到序列的极值 可采用随机算法或者随机3个值取中间值的方法尽量使轴点最优

### quickSort的空间复杂度
    每次轴点构造算法需要O(1)的空间备份选定的轴点值 递归log n次 共需要1 * log n的空间

### heapSort的优化
### heapSort最好、最坏、平均时间复杂度分析

## 查找算法
### 二分查找的几种优化
### 二分查找的最好、最坏、平均时间复杂度分析

## 空间随机化算法
### 向量置乱算法

## 算法优化
### 无序向量去重算法的优化(突破O(n^2))

## 其他
### vecotr空间扩展expand以*2扩展的优势
### memmove解决内存重叠问题,具体的实现

### list有序区间和无序区间查找的区别

## 线性序列的缺陷
    vector查找的最好效率是O(log(n))最坏效率是O(n)
          动态修改的效率是O(n)
    list查找的效率最好最坏都是O(n)
          动态修改的效率是O(1)
          
## 线性序列的应用(特定的操作方式)
### 栈(后进先出)
    逆序
    数据缓冲
    延迟计算
### 队列(先进先出)
    排队模型
    优先级
    顺序性(层次遍历)
### 栈及队列的应用
    进制转换、括号匹配、栈混洗、表达式求值、递归优化
    排队模型
