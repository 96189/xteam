
# muduo源码学习 #

## 线程同步 ##

* 原子操作

防止编译器优化的类型指示符
    volatile
    
编译器原子操作指令

    GET -> __sync_val_compare_and_swap
    ADD -> __sync_fetch_and_add
    SET -> __sync_lock_test_and_set

* 线程锁

    RAII + pthread_mutex_XXX系列函数实现自动管理生命周期的线程锁

* 条件变量

    pthread_cond_t

* CountDownLatch

    用于线程间的同步,常用于主线程等待其他n个线程完成之后主线程才执行自己的后续任务,这是主线程与其他线程之间的执行序列同步关系.

## 阻塞队列 ##

* 为什么需要阻塞队列?

如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。然而，在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。好在此时，强大的concurrent包横空出世了，而他也给我们带来了强大的BlockingQueue。（在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒）

作为BlockingQueue的使用者，我们再也不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了。

* BlockingQueue

    queue + mutex + condition(不空的条件变量)

* BoundedBlockingQueue(限制大小的阻塞队列)

由于限制了队列大小 需要不满的条件变量来防止数据插入造成队列满
    queue + mutex + condition(不空的条件变量) + condition(不满的条件变量)


## 线程池 ##

* 线程创建

    c的pthread_create函数

* 线程私有数据(线程函数参数)ThreadData

    线程私有数据整个线程内具有全局作用域,各线程有各自的实体
    __thread关键字表示线程私有数据
    pthread_key_create函数创建kv结构的线程私有数据

* 线程池

线程锁

    同一时刻是有一个线程向线程池添加任务

线程池数组

    每个线程在线程池队列上阻塞等待拿到任务

任务队列

    生产者消费者问题 队列空时阻塞消费者  队列满时阻塞生产者

队列条件变量

    满条件变量 空条件变量

线程执行函数

    阻塞在任务队列等待获取任务执行

* QA

    typedef boost::function<void ()> Task;任务参数如何传递?