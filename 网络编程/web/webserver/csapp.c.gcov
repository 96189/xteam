        -:    0:Source:csapp.c
        -:    0:Programs:4
        -:    1:/* $begin csapp.c */
        -:    2:#include "csapp.h"
        -:    3:
        -:    4:/************************** 
        -:    5: * Error-handling functions
        -:    6: **************************/
        -:    7:/* $begin errorfuns */
        -:    8:/* $begin unixerror */
function unix_error called 0 returned 0% blocks executed 0%
    #####:    9:void unix_error(char *msg) /* unix-style error */
    $$$$$:    9-block  0
        -:   10:{
    #####:   11:    fprintf(stderr, "%s: %s\n", msg, strerror(errno));
    $$$$$:   11-block  0
call    0 never executed
call    1 never executed
    #####:   12:    exit(0);
        -:   13:}
        -:   14:/* $end unixerror */
        -:   15:
function posix_error called 0 returned 0% blocks executed 0%
    #####:   16:void posix_error(int code, char *msg) /* posix-style error */
    $$$$$:   16-block  0
        -:   17:{
    #####:   18:    fprintf(stderr, "%s: %s\n", msg, strerror(code));
    $$$$$:   18-block  0
call    0 never executed
call    1 never executed
    #####:   19:    exit(0);
        -:   20:}
        -:   21:
function dns_error called 0 returned 0% blocks executed 0%
    #####:   22:void dns_error(char *msg) /* dns-style error */
    $$$$$:   22-block  0
        -:   23:{
    #####:   24:    fprintf(stderr, "%s: DNS error %d\n", msg, h_errno);
    $$$$$:   24-block  0
call    0 never executed
    #####:   25:    exit(0);
        -:   26:}
        -:   27:
function app_error called 0 returned 0% blocks executed 0%
    #####:   28:void app_error(char *msg) /* application error */
    $$$$$:   28-block  0
        -:   29:{
    #####:   30:    fprintf(stderr, "%s\n", msg);
    $$$$$:   30-block  0
call    0 never executed
    #####:   31:    exit(0);
        -:   32:}
        -:   33:/* $end errorfuns */
        -:   34:
        -:   35:/*********************************************
        -:   36: * Wrappers for Unix process control functions
        -:   37: ********************************************/
        -:   38:
        -:   39:/* $begin forkwrapper */
function Fork called 0 returned 0% blocks executed 0%
    #####:   40:pid_t Fork(void) 
    $$$$$:   40-block  0
        -:   41:{
        -:   42:    pid_t pid;
        -:   43:
    #####:   44:    if ((pid = fork()) < 0)
    $$$$$:   44-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   45:    unix_error("Fork error");
    $$$$$:   45-block  0
call    0 never executed
    #####:   46:    return pid;
    $$$$$:   46-block  0
        -:   47:}
        -:   48:/* $end forkwrapper */
        -:   49:
function Execve called 0 returned 0% blocks executed 0%
    #####:   50:void Execve(const char *filename, char *const argv[], char *const envp[]) 
    $$$$$:   50-block  0
        -:   51:{
    #####:   52:    if (execve(filename, argv, envp) < 0)
    $$$$$:   52-block  0
branch  0 never executed
branch  1 never executed
    #####:   53:    unix_error("Execve error");
    $$$$$:   53-block  0
call    0 never executed
    #####:   54:}
        -:   55:
        -:   56:/* $begin wait */
function Wait called 0 returned 0% blocks executed 0%
    #####:   57:pid_t Wait(int *status) 
    $$$$$:   57-block  0
        -:   58:{
        -:   59:    pid_t pid;
        -:   60:
    #####:   61:    if ((pid  = wait(status)) < 0)
    $$$$$:   61-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   62:    unix_error("Wait error");
    $$$$$:   62-block  0
call    0 never executed
    #####:   63:    return pid;
    $$$$$:   63-block  0
        -:   64:}
        -:   65:/* $end wait */
        -:   66:
function Waitpid called 0 returned 0% blocks executed 0%
    #####:   67:pid_t Waitpid(pid_t pid, int *iptr, int options) 
    $$$$$:   67-block  0
        -:   68:{
        -:   69:    pid_t retpid;
        -:   70:
    #####:   71:    if ((retpid  = waitpid(pid, iptr, options)) < 0) 
    $$$$$:   71-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   72:    unix_error("Waitpid error");
    $$$$$:   72-block  0
call    0 never executed
    #####:   73:    return(retpid);
    $$$$$:   73-block  0
        -:   74:}
        -:   75:
        -:   76:/* $begin kill */
function Kill called 0 returned 0% blocks executed 0%
    #####:   77:void Kill(pid_t pid, int signum) 
    $$$$$:   77-block  0
        -:   78:{
        -:   79:    int rc;
        -:   80:
    #####:   81:    if ((rc = kill(pid, signum)) < 0)
    $$$$$:   81-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   82:    unix_error("Kill error");
    $$$$$:   82-block  0
call    0 never executed
    #####:   83:}
        -:   84:/* $end kill */
        -:   85:
function Pause called 0 returned 0% blocks executed 0%
    #####:   86:void Pause() 
    $$$$$:   86-block  0
        -:   87:{
    #####:   88:    (void)pause();
    $$$$$:   88-block  0
call    0 never executed
    #####:   89:    return;
        -:   90:}
        -:   91:
function Sleep called 0 returned 0% blocks executed 0%
    #####:   92:unsigned int Sleep(unsigned int secs) 
    $$$$$:   92-block  0
        -:   93:{
        -:   94:    unsigned int rc;
        -:   95:
    #####:   96:    if ((rc = sleep(secs)) < 0)
    $$$$$:   96-block  0
call    0 never executed
        -:   97:    unix_error("Sleep error");
    #####:   98:    return rc;
        -:   99:}
        -:  100:
function Alarm called 0 returned 0% blocks executed 0%
    #####:  101:unsigned int Alarm(unsigned int seconds) {
    $$$$$:  101-block  0
    #####:  102:    return alarm(seconds);
    $$$$$:  102-block  0
call    0 never executed
        -:  103:}
        -:  104: 
function Setpgid called 0 returned 0% blocks executed 0%
    #####:  105:void Setpgid(pid_t pid, pid_t pgid) {
    $$$$$:  105-block  0
        -:  106:    int rc;
        -:  107:
    #####:  108:    if ((rc = setpgid(pid, pgid)) < 0)
    $$$$$:  108-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  109:    unix_error("Setpgid error");
    $$$$$:  109-block  0
call    0 never executed
    #####:  110:    return;
    $$$$$:  110-block  0
        -:  111:}
        -:  112:
function Getpgrp called 0 returned 0% blocks executed 0%
    #####:  113:pid_t Getpgrp(void) {
    $$$$$:  113-block  0
    #####:  114:    return getpgrp();
    $$$$$:  114-block  0
call    0 never executed
        -:  115:}
        -:  116:
        -:  117:/************************************
        -:  118: * Wrappers for Unix signal functions 
        -:  119: ***********************************/
        -:  120:
        -:  121:/* $begin sigaction */
function Signal called 0 returned 0% blocks executed 0%
    #####:  122:handler_t *Signal(int signum, handler_t *handler) 
    $$$$$:  122-block  0
        -:  123:{
        -:  124:    struct sigaction action, old_action;
        -:  125:
    #####:  126:    action.sa_handler = handler;  
    #####:  127:    sigemptyset(&action.sa_mask); /* block sigs of type being handled */
    $$$$$:  127-block  0
call    0 never executed
    #####:  128:    action.sa_flags = SA_RESTART; /* restart syscalls if possible */
        -:  129:
    #####:  130:    if (sigaction(signum, &action, &old_action) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  131:        unix_error("Signal error");
    $$$$$:  131-block  0
call    0 never executed
    #####:  132:    return (old_action.sa_handler);
    $$$$$:  132-block  0
        -:  133:}
        -:  134:/* $end sigaction */
        -:  135:
function Sigprocmask called 0 returned 0% blocks executed 0%
    #####:  136:void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset)
    $$$$$:  136-block  0
        -:  137:{
    #####:  138:    if (sigprocmask(how, set, oldset) < 0)
    $$$$$:  138-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  139:    unix_error("Sigprocmask error");
    $$$$$:  139-block  0
call    0 never executed
    #####:  140:    return;
    $$$$$:  140-block  0
        -:  141:}
        -:  142:
function Sigemptyset called 0 returned 0% blocks executed 0%
    #####:  143:void Sigemptyset(sigset_t *set)
    $$$$$:  143-block  0
        -:  144:{
    #####:  145:    if (sigemptyset(set) < 0)
    $$$$$:  145-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  146:    unix_error("Sigemptyset error");
    $$$$$:  146-block  0
call    0 never executed
    #####:  147:    return;
    $$$$$:  147-block  0
        -:  148:}
        -:  149:
function Sigfillset called 0 returned 0% blocks executed 0%
    #####:  150:void Sigfillset(sigset_t *set)
    $$$$$:  150-block  0
        -:  151:{ 
    #####:  152:    if (sigfillset(set) < 0)
    $$$$$:  152-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  153:    unix_error("Sigfillset error");
    $$$$$:  153-block  0
call    0 never executed
    #####:  154:    return;
    $$$$$:  154-block  0
        -:  155:}
        -:  156:
function Sigaddset called 0 returned 0% blocks executed 0%
    #####:  157:void Sigaddset(sigset_t *set, int signum)
    $$$$$:  157-block  0
        -:  158:{
    #####:  159:    if (sigaddset(set, signum) < 0)
    $$$$$:  159-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  160:    unix_error("Sigaddset error");
    $$$$$:  160-block  0
call    0 never executed
    #####:  161:    return;
    $$$$$:  161-block  0
        -:  162:}
        -:  163:
function Sigdelset called 0 returned 0% blocks executed 0%
    #####:  164:void Sigdelset(sigset_t *set, int signum)
    $$$$$:  164-block  0
        -:  165:{
    #####:  166:    if (sigdelset(set, signum) < 0)
    $$$$$:  166-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  167:    unix_error("Sigdelset error");
    $$$$$:  167-block  0
call    0 never executed
    #####:  168:    return;
    $$$$$:  168-block  0
        -:  169:}
        -:  170:
function Sigismember called 0 returned 0% blocks executed 0%
    #####:  171:int Sigismember(const sigset_t *set, int signum)
    $$$$$:  171-block  0
        -:  172:{
        -:  173:    int rc;
    #####:  174:    if ((rc = sigismember(set, signum)) < 0)
    $$$$$:  174-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  175:    unix_error("Sigismember error");
    $$$$$:  175-block  0
call    0 never executed
    #####:  176:    return rc;
    $$$$$:  176-block  0
        -:  177:}
        -:  178:
        -:  179:
        -:  180:/********************************
        -:  181: * Wrappers for Unix I/O routines
        -:  182: ********************************/
        -:  183:
function Open called 0 returned 0% blocks executed 0%
    #####:  184:int Open(const char *pathname, int flags, mode_t mode) 
    $$$$$:  184-block  0
        -:  185:{
        -:  186:    int rc;
        -:  187:
    #####:  188:    if ((rc = open(pathname, flags, mode))  < 0)
    $$$$$:  188-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  189:        unix_error("Open error");
    $$$$$:  189-block  0
call    0 never executed
    #####:  190:    return rc;
    $$$$$:  190-block  0
        -:  191:}
        -:  192:
function Read called 0 returned 0% blocks executed 0%
    #####:  193:ssize_t Read(int fd, void *buf, size_t count) 
    $$$$$:  193-block  0
        -:  194:{
        -:  195:    ssize_t rc;
        -:  196:
    #####:  197:    if ((rc = read(fd, buf, count)) < 0) 
    $$$$$:  197-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  198:        unix_error("Read error");
    $$$$$:  198-block  0
call    0 never executed
    #####:  199:    return rc;
    $$$$$:  199-block  0
        -:  200:}
        -:  201:
function Write called 0 returned 0% blocks executed 0%
    #####:  202:ssize_t Write(int fd, const void *buf, size_t count) 
    $$$$$:  202-block  0
        -:  203:{
        -:  204:    ssize_t rc;
        -:  205:
    #####:  206:    if ((rc = write(fd, buf, count)) < 0)
    $$$$$:  206-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  207:        unix_error("Write error");
    $$$$$:  207-block  0
call    0 never executed
    #####:  208:    return rc;
    $$$$$:  208-block  0
        -:  209:}
        -:  210:
function Lseek called 0 returned 0% blocks executed 0%
    #####:  211:off_t Lseek(int fildes, off_t offset, int whence) 
    $$$$$:  211-block  0
        -:  212:{
        -:  213:    off_t rc;
        -:  214:
    #####:  215:    if ((rc = lseek(fildes, offset, whence)) < 0)
    $$$$$:  215-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  216:        unix_error("Lseek error");
    $$$$$:  216-block  0
call    0 never executed
    #####:  217:    return rc;
    $$$$$:  217-block  0
        -:  218:}
        -:  219:
function Close called 0 returned 0% blocks executed 0%
    #####:  220:void Close(int fd) 
    $$$$$:  220-block  0
        -:  221:{
        -:  222:    int rc;
        -:  223:
    #####:  224:    if ((rc = close(fd)) < 0)
    $$$$$:  224-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  225:        unix_error("Close error");
    $$$$$:  225-block  0
call    0 never executed
    #####:  226:}
        -:  227:
function Select called 0 returned 0% blocks executed 0%
    #####:  228:int Select(int  n, fd_set *readfds, fd_set *writefds,
    $$$$$:  228-block  0
        -:  229:       fd_set *exceptfds, struct timeval *timeout) 
        -:  230:{
        -:  231:    int rc;
        -:  232:
    #####:  233:    if ((rc = select(n, readfds, writefds, exceptfds, timeout)) < 0)
    $$$$$:  233-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  234:        unix_error("Select error");
    $$$$$:  234-block  0
call    0 never executed
    #####:  235:    return rc;
    $$$$$:  235-block  0
        -:  236:}
        -:  237:
function Dup2 called 0 returned 0% blocks executed 0%
    #####:  238:int Dup2(int fd1, int fd2) 
    $$$$$:  238-block  0
        -:  239:{
        -:  240:    int rc;
        -:  241:
    #####:  242:    if ((rc = dup2(fd1, fd2)) < 0)
    $$$$$:  242-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  243:        unix_error("Dup2 error");
    $$$$$:  243-block  0
call    0 never executed
    #####:  244:    return rc;
    $$$$$:  244-block  0
        -:  245:}
        -:  246:
function Stat called 0 returned 0% blocks executed 0%
    #####:  247:void Stat(const char *filename, struct stat *buf) 
    $$$$$:  247-block  0
        -:  248:{
    #####:  249:    if (stat(filename, buf) < 0)
    $$$$$:  249-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  250:        unix_error("Stat error");
    $$$$$:  250-block  0
call    0 never executed
    #####:  251:}
        -:  252:
function Fstat called 0 returned 0% blocks executed 0%
    #####:  253:void Fstat(int fd, struct stat *buf) 
    $$$$$:  253-block  0
        -:  254:{
    #####:  255:    if (fstat(fd, buf) < 0)
    $$$$$:  255-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  256:        unix_error("Fstat error");
    $$$$$:  256-block  0
call    0 never executed
    #####:  257:}
        -:  258:
        -:  259:/***************************************
        -:  260: * Wrappers for memory mapping functions
        -:  261: ***************************************/
function Mmap called 0 returned 0% blocks executed 0%
    #####:  262:void *Mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset) 
    $$$$$:  262-block  0
        -:  263:{
        -:  264:    void *ptr;
        -:  265:
    #####:  266:    if ((ptr = mmap(addr, len, prot, flags, fd, offset)) == ((void *) -1))
    $$$$$:  266-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  267:        unix_error("mmap error");
    $$$$$:  267-block  0
call    0 never executed
    #####:  268:    return(ptr);
    $$$$$:  268-block  0
        -:  269:}
        -:  270:
function Munmap called 0 returned 0% blocks executed 0%
    #####:  271:void Munmap(void *start, size_t length) 
    $$$$$:  271-block  0
        -:  272:{
    #####:  273:    if (munmap(start, length) < 0)
    $$$$$:  273-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  274:        unix_error("munmap error");
    $$$$$:  274-block  0
call    0 never executed
    #####:  275:}
        -:  276:
        -:  277:/***************************************************
        -:  278: * Wrappers for dynamic storage allocation functions
        -:  279: ***************************************************/
        -:  280:
function Malloc called 0 returned 0% blocks executed 0%
    #####:  281:void *Malloc(size_t size) 
    $$$$$:  281-block  0
        -:  282:{
        -:  283:    void *p;
        -:  284:
    #####:  285:    if ((p  = malloc(size)) == NULL)
    $$$$$:  285-block  0
branch  0 never executed
branch  1 never executed
    #####:  286:        unix_error("Malloc error");
    $$$$$:  286-block  0
call    0 never executed
    #####:  287:    return p;
    $$$$$:  287-block  0
        -:  288:}
        -:  289:
function Realloc called 0 returned 0% blocks executed 0%
    #####:  290:void *Realloc(void *ptr, size_t size) 
    $$$$$:  290-block  0
        -:  291:{
        -:  292:    void *p;
        -:  293:
    #####:  294:    if ((p  = realloc(ptr, size)) == NULL)
    $$$$$:  294-block  0
branch  0 never executed
branch  1 never executed
    #####:  295:        unix_error("Realloc error");
    $$$$$:  295-block  0
call    0 never executed
    #####:  296:    return p;
    $$$$$:  296-block  0
        -:  297:}
        -:  298:
function Calloc called 0 returned 0% blocks executed 0%
    #####:  299:void *Calloc(size_t nmemb, size_t size) 
    $$$$$:  299-block  0
        -:  300:{
        -:  301:    void *p;
        -:  302:
    #####:  303:    if ((p = calloc(nmemb, size)) == NULL)
    $$$$$:  303-block  0
branch  0 never executed
branch  1 never executed
    #####:  304:        unix_error("Calloc error");
    $$$$$:  304-block  0
call    0 never executed
    #####:  305:    return p;
    $$$$$:  305-block  0
        -:  306:}
        -:  307:
function Free called 0 returned 0% blocks executed 0%
    #####:  308:void Free(void *ptr) 
    $$$$$:  308-block  0
        -:  309:{
    #####:  310:    free(ptr);
    #####:  311:}
        -:  312:
        -:  313:/******************************************
        -:  314: * Wrappers for the Standard I/O functions.
        -:  315: ******************************************/
function Fclose called 0 returned 0% blocks executed 0%
    #####:  316:void Fclose(FILE *fp) 
    $$$$$:  316-block  0
        -:  317:{
    #####:  318:    if (fclose(fp) != 0)
    $$$$$:  318-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  319:        unix_error("Fclose error");
    $$$$$:  319-block  0
call    0 never executed
    #####:  320:}
        -:  321:
function Fdopen called 0 returned 0% blocks executed 0%
    #####:  322:FILE *Fdopen(int fd, const char *type) 
    $$$$$:  322-block  0
        -:  323:{
        -:  324:    FILE *fp;
        -:  325:
    #####:  326:    if ((fp = fdopen(fd, type)) == NULL)
    $$$$$:  326-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  327:        unix_error("Fdopen error");
    $$$$$:  327-block  0
call    0 never executed
        -:  328:
    #####:  329:    return fp;
    $$$$$:  329-block  0
        -:  330:}
        -:  331:
function Fgets called 0 returned 0% blocks executed 0%
    #####:  332:char *Fgets(char *ptr, int n, FILE *stream) 
    $$$$$:  332-block  0
        -:  333:{
        -:  334:    char *rptr;
        -:  335:
    #####:  336:    if (((rptr = fgets(ptr, n, stream)) == NULL) && ferror(stream))
    $$$$$:  336-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:  336-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  337:        app_error("Fgets error");
    $$$$$:  337-block  0
call    0 never executed
        -:  338:
    #####:  339:    return rptr;
    $$$$$:  339-block  0
        -:  340:}
        -:  341:
function Fopen called 0 returned 0% blocks executed 0%
    #####:  342:FILE *Fopen(const char *filename, const char *mode) 
    $$$$$:  342-block  0
        -:  343:{
        -:  344:    FILE *fp;
        -:  345:
    #####:  346:    if ((fp = fopen(filename, mode)) == NULL)
    $$$$$:  346-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  347:        unix_error("Fopen error");
    $$$$$:  347-block  0
call    0 never executed
        -:  348:
    #####:  349:    return fp;
    $$$$$:  349-block  0
        -:  350:}
        -:  351:
function Fputs called 0 returned 0% blocks executed 0%
    #####:  352:void Fputs(const char *ptr, FILE *stream) 
    $$$$$:  352-block  0
        -:  353:{
    #####:  354:    if (fputs(ptr, stream) == EOF)
    $$$$$:  354-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  355:        unix_error("Fputs error");
    $$$$$:  355-block  0
call    0 never executed
    #####:  356:}
        -:  357:
function Fread called 0 returned 0% blocks executed 0%
    #####:  358:size_t Fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 
    $$$$$:  358-block  0
        -:  359:{
        -:  360:    size_t n;
        -:  361:
    #####:  362:    if (((n = fread(ptr, size, nmemb, stream)) < nmemb) && ferror(stream)) 
    $$$$$:  362-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:  362-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  363:        unix_error("Fread error");
    $$$$$:  363-block  0
call    0 never executed
    #####:  364:    return n;
    $$$$$:  364-block  0
        -:  365:}
        -:  366:
function Fwrite called 0 returned 0% blocks executed 0%
    #####:  367:void Fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 
    $$$$$:  367-block  0
        -:  368:{
    #####:  369:    if (fwrite(ptr, size, nmemb, stream) < nmemb)
    $$$$$:  369-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  370:        unix_error("Fwrite error");
    $$$$$:  370-block  0
call    0 never executed
    #####:  371:}
        -:  372:
        -:  373:
        -:  374:/**************************** 
        -:  375: * Sockets interface wrappers
        -:  376: ****************************/
        -:  377:
function Socket called 0 returned 0% blocks executed 0%
    #####:  378:int Socket(int domain, int type, int protocol) 
    $$$$$:  378-block  0
        -:  379:{
        -:  380:    int rc;
        -:  381:
    #####:  382:    if ((rc = socket(domain, type, protocol)) < 0)
    $$$$$:  382-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  383:        unix_error("Socket error");
    $$$$$:  383-block  0
call    0 never executed
    #####:  384:    return rc;
    $$$$$:  384-block  0
        -:  385:}
        -:  386:
function Setsockopt called 0 returned 0% blocks executed 0%
    #####:  387:void Setsockopt(int s, int level, int optname, const void *optval, int optlen) 
    $$$$$:  387-block  0
        -:  388:{
        -:  389:    int rc;
        -:  390:
    #####:  391:    if ((rc = setsockopt(s, level, optname, optval, optlen)) < 0)
    $$$$$:  391-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  392:        unix_error("Setsockopt error");
    $$$$$:  392-block  0
call    0 never executed
    #####:  393:}
        -:  394:
function Bind called 0 returned 0% blocks executed 0%
    #####:  395:void Bind(int sockfd, struct sockaddr *my_addr, int addrlen) 
    $$$$$:  395-block  0
        -:  396:{
        -:  397:    int rc;
        -:  398:
    #####:  399:    if ((rc = bind(sockfd, my_addr, addrlen)) < 0)
    $$$$$:  399-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  400:    unix_error("Bind error");
    $$$$$:  400-block  0
call    0 never executed
    #####:  401:}
        -:  402:
function Listen called 0 returned 0% blocks executed 0%
    #####:  403:void Listen(int s, int backlog) 
    $$$$$:  403-block  0
        -:  404:{
        -:  405:    int rc;
        -:  406:
    #####:  407:    if ((rc = listen(s,  backlog)) < 0)
    $$$$$:  407-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  408:    unix_error("Listen error");
    $$$$$:  408-block  0
call    0 never executed
    #####:  409:}
        -:  410:
function Accept called 1 returned 0% blocks executed 40%
        1:  411:int Accept(int s, struct sockaddr *addr, socklen_t *addrlen) 
        1:  411-block  0
        -:  412:{
        -:  413:    int rc;
        -:  414:
        1:  415:    if ((rc = accept(s, addr, addrlen)) < 0)
        1:  415-block  0
call    0 returned 0
branch  1 never executed
branch  2 never executed
    #####:  416:    unix_error("Accept error");
    $$$$$:  416-block  0
call    0 never executed
    #####:  417:    return rc;
    $$$$$:  417-block  0
        -:  418:}
        -:  419:
function Connect called 0 returned 0% blocks executed 0%
    #####:  420:void Connect(int sockfd, struct sockaddr *serv_addr, int addrlen) 
    $$$$$:  420-block  0
        -:  421:{
        -:  422:    int rc;
        -:  423:
    #####:  424:    if ((rc = connect(sockfd, serv_addr, addrlen)) < 0)
    $$$$$:  424-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  425:    unix_error("Connect error");
    $$$$$:  425-block  0
call    0 never executed
    #####:  426:}
        -:  427:
        -:  428:/************************
        -:  429: * DNS interface wrappers 
        -:  430: ***********************/
        -:  431:
        -:  432:/* $begin gethostbyname */
function Gethostbyname called 0 returned 0% blocks executed 0%
    #####:  433:struct hostent *Gethostbyname(const char *name) 
    $$$$$:  433-block  0
        -:  434:{
        -:  435:    struct hostent *p;
        -:  436:
    #####:  437:    if ((p = gethostbyname(name)) == NULL)
    $$$$$:  437-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  438:        dns_error("Gethostbyname error");
    $$$$$:  438-block  0
call    0 never executed
    #####:  439:    return p;
    $$$$$:  439-block  0
        -:  440:}
        -:  441:/* $end gethostbyname */
        -:  442:
function Gethostbyaddr called 0 returned 0% blocks executed 0%
    #####:  443:struct hostent *Gethostbyaddr(const char *addr, int len, int type) 
    $$$$$:  443-block  0
        -:  444:{
        -:  445:    struct hostent *p;
        -:  446:
    #####:  447:    if ((p = gethostbyaddr(addr, len, type)) == NULL)
    $$$$$:  447-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  448:        dns_error("Gethostbyaddr error");
    $$$$$:  448-block  0
call    0 never executed
    #####:  449:    return p;
    $$$$$:  449-block  0
        -:  450:}
        -:  451:
        -:  452:/************************************************
        -:  453: * Wrappers for Pthreads thread control functions
        -:  454: ************************************************/
        -:  455:
function Pthread_create called 0 returned 0% blocks executed 0%
    #####:  456:void Pthread_create(pthread_t *tidp, pthread_attr_t *attrp, 
    $$$$$:  456-block  0
        -:  457:            void * (*routine)(void *), void *argp) 
        -:  458:{
        -:  459:    int rc;
        -:  460:
    #####:  461:    if ((rc = pthread_create(tidp, attrp, routine, argp)) != 0)
    $$$$$:  461-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  462:    posix_error(rc, "Pthread_create error");
    $$$$$:  462-block  0
call    0 never executed
    #####:  463:}
        -:  464:
function Pthread_cancel called 0 returned 0% blocks executed 0%
    #####:  465:void Pthread_cancel(pthread_t tid) {
    $$$$$:  465-block  0
        -:  466:    int rc;
        -:  467:
    #####:  468:    if ((rc = pthread_cancel(tid)) != 0)
    $$$$$:  468-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  469:    posix_error(rc, "Pthread_cancel error");
    $$$$$:  469-block  0
call    0 never executed
    #####:  470:}
        -:  471:
function Pthread_join called 0 returned 0% blocks executed 0%
    #####:  472:void Pthread_join(pthread_t tid, void **thread_return) {
    $$$$$:  472-block  0
        -:  473:    int rc;
        -:  474:
    #####:  475:    if ((rc = pthread_join(tid, thread_return)) != 0)
    $$$$$:  475-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  476:    posix_error(rc, "Pthread_join error");
    $$$$$:  476-block  0
call    0 never executed
    #####:  477:}
        -:  478:
        -:  479:/* $begin detach */
function Pthread_detach called 0 returned 0% blocks executed 0%
    #####:  480:void Pthread_detach(pthread_t tid) {
    $$$$$:  480-block  0
        -:  481:    int rc;
        -:  482:
    #####:  483:    if ((rc = pthread_detach(tid)) != 0)
    $$$$$:  483-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  484:    posix_error(rc, "Pthread_detach error");
    $$$$$:  484-block  0
call    0 never executed
    #####:  485:}
        -:  486:/* $end detach */
        -:  487:
function Pthread_exit called 0 returned 0% blocks executed 0%
    #####:  488:void Pthread_exit(void *retval) {
    $$$$$:  488-block  0
    #####:  489:    pthread_exit(retval);
        -:  490:}
        -:  491:
function Pthread_self called 0 returned 0% blocks executed 0%
    #####:  492:pthread_t Pthread_self(void) {
    $$$$$:  492-block  0
    #####:  493:    return pthread_self();
    $$$$$:  493-block  0
        -:  494:}
        -:  495: 
function Pthread_once called 0 returned 0% blocks executed 0%
    #####:  496:void Pthread_once(pthread_once_t *once_control, void (*init_function)()) {
    $$$$$:  496-block  0
    #####:  497:    pthread_once(once_control, init_function);
    $$$$$:  497-block  0
call    0 never executed
    #####:  498:}
        -:  499:
        -:  500:/*******************************
        -:  501: * Wrappers for Posix semaphores
        -:  502: *******************************/
        -:  503:
function Sem_init called 0 returned 0% blocks executed 0%
    #####:  504:void Sem_init(sem_t *sem, int pshared, unsigned int value) 
    $$$$$:  504-block  0
        -:  505:{
    #####:  506:    if (sem_init(sem, pshared, value) < 0)
    $$$$$:  506-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  507:    unix_error("Sem_init error");
    $$$$$:  507-block  0
call    0 never executed
    #####:  508:}
        -:  509:
function P called 0 returned 0% blocks executed 0%
    #####:  510:void P(sem_t *sem) 
    $$$$$:  510-block  0
        -:  511:{
    #####:  512:    if (sem_wait(sem) < 0)
    $$$$$:  512-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  513:    unix_error("P error");
    $$$$$:  513-block  0
call    0 never executed
    #####:  514:}
        -:  515:
function V called 0 returned 0% blocks executed 0%
    #####:  516:void V(sem_t *sem) 
    $$$$$:  516-block  0
        -:  517:{
    #####:  518:    if (sem_post(sem) < 0)
    $$$$$:  518-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  519:    unix_error("V error");
    $$$$$:  519-block  0
call    0 never executed
    #####:  520:}
        -:  521:
        -:  522:/*********************************************************************
        -:  523: * The Rio package - robust I/O functions
        -:  524: **********************************************************************/
        -:  525:/*
        -:  526: * rio_readn - robustly read n bytes (unbuffered)
        -:  527: */
        -:  528:/* $begin rio_readn */
function rio_readn called 0 returned 0% blocks executed 0%
    #####:  529:ssize_t rio_readn(int fd, void *usrbuf, size_t n) 
    $$$$$:  529-block  0
        -:  530:{
    #####:  531:    size_t nleft = n;
        -:  532:    ssize_t nread;
    #####:  533:    char *bufp = usrbuf;
        -:  534:
    #####:  535:    while (nleft > 0) {
    $$$$$:  535-block  0
    $$$$$:  535-block  1
branch  0 never executed
branch  1 never executed
    #####:  536:        if ((nread = read(fd, bufp, nleft)) < 0) {
    $$$$$:  536-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  537:            if (errno == EINTR) /* interrupted by sig handler return */
    $$$$$:  537-block  0
branch  0 never executed
branch  1 never executed
    #####:  538:                nread = 0;      /* and call read() again */
    $$$$$:  538-block  0
        -:  539:            else
    #####:  540:                return -1;      /* errno set by read() */ 
    $$$$$:  540-block  0
        -:  541:        } 
    #####:  542:        else if (nread == 0)
    $$$$$:  542-block  0
branch  0 never executed
branch  1 never executed
    #####:  543:            break;              /* EOF */
    $$$$$:  543-block  0
    #####:  544:        nleft -= nread;
    #####:  545:        bufp += nread;
    $$$$$:  545-block  0
        -:  546:    }
    #####:  547:    return (n - nleft);         /* return >= 0 */
    $$$$$:  547-block  0
        -:  548:}
        -:  549:/* $end rio_readn */
        -:  550:
        -:  551:/*
        -:  552: * rio_writen - robustly write n bytes (unbuffered)
        -:  553: */
        -:  554:/* $begin rio_writen */
function rio_writen called 0 returned 0% blocks executed 0%
    #####:  555:ssize_t rio_writen(int fd, void *usrbuf, size_t n) 
    $$$$$:  555-block  0
        -:  556:{
    #####:  557:    size_t nleft = n;
        -:  558:    ssize_t nwritten;
    #####:  559:    char *bufp = usrbuf;
        -:  560:
    #####:  561:    while (nleft > 0) {
    $$$$$:  561-block  0
    $$$$$:  561-block  1
branch  0 never executed
branch  1 never executed
    #####:  562:    if ((nwritten = write(fd, bufp, nleft)) <= 0) {
    $$$$$:  562-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  563:        if (errno == EINTR)  /* interrupted by sig handler return */
    $$$$$:  563-block  0
branch  0 never executed
branch  1 never executed
    #####:  564:            nwritten = 0;    /* and call write() again */
    $$$$$:  564-block  0
        -:  565:        else
        -:  566:	{
    #####:  567:            return -1;       /* errno set by write() */
    $$$$$:  567-block  0
        -:  568:	}    
        -:  569:	}
    #####:  570:    nleft -= nwritten;
    #####:  571:    bufp += nwritten;
    $$$$$:  571-block  0
        -:  572:    }
    #####:  573:    return n;
    $$$$$:  573-block  0
        -:  574:}
        -:  575:/* $end rio_writen */
        -:  576:
        -:  577:
        -:  578:/* 
        -:  579: * rio_read - This is a wrapper for the Unix read() function that
        -:  580: *    transfers min(n, rio_cnt) bytes from an internal buffer to a user
        -:  581: *    buffer, where n is the number of bytes requested by the user and
        -:  582: *    rio_cnt is the number of unread bytes in the internal buffer. On
        -:  583: *    entry, rio_read() refills the internal buffer via a call to
        -:  584: *    read() if the internal buffer is empty.
        -:  585: */
        -:  586:/* $begin rio_read */
function rio_read called 0 returned 0% blocks executed 0%
    #####:  587:static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)
    $$$$$:  587-block  0
        -:  588:{
        -:  589:    int cnt;
        -:  590:
    #####:  591:    while (rp->rio_cnt <= 0) {  /* refill if buf is empty */
    $$$$$:  591-block  0
    $$$$$:  591-block  1
branch  0 never executed
branch  1 never executed
    #####:  592:    rp->rio_cnt = read(rp->rio_fd, rp->rio_buf, 
    $$$$$:  592-block  0
call    0 never executed
        -:  593:               sizeof(rp->rio_buf));
    #####:  594:    if (rp->rio_cnt < 0) {
branch  0 never executed
branch  1 never executed
    #####:  595:        if (errno != EINTR) /* interrupted by sig handler return */
    $$$$$:  595-block  0
branch  0 never executed
branch  1 never executed
    #####:  596:        return -1;
    $$$$$:  596-block  0
        -:  597:    }
    #####:  598:    else if (rp->rio_cnt == 0)  /* EOF */
    $$$$$:  598-block  0
branch  0 never executed
branch  1 never executed
    #####:  599:        return 0;
    $$$$$:  599-block  0
        -:  600:    else 
    #####:  601:        rp->rio_bufptr = rp->rio_buf; /* reset buffer ptr */
    $$$$$:  601-block  0
        -:  602:    }
        -:  603:
        -:  604:    /* Copy min(n, rp->rio_cnt) bytes from internal buf to user buf */
    #####:  605:    cnt = n;          
    #####:  606:    if (rp->rio_cnt < n)   
    $$$$$:  606-block  0
branch  0 never executed
branch  1 never executed
    #####:  607:    cnt = rp->rio_cnt;
    $$$$$:  607-block  0
    #####:  608:    memcpy(usrbuf, rp->rio_bufptr, cnt);
    #####:  609:    rp->rio_bufptr += cnt;
    #####:  610:    rp->rio_cnt -= cnt;
    #####:  611:    return cnt;
    $$$$$:  611-block  0
        -:  612:}
        -:  613:/* $end rio_read */
        -:  614:
        -:  615:/*
        -:  616: * rio_readinitb - Associate a descriptor with a read buffer and reset buffer
        -:  617: */
        -:  618:/* $begin rio_readinitb */
function rio_readinitb called 0 returned 0% blocks executed 0%
    #####:  619:void rio_readinitb(rio_t *rp, int fd) 
    $$$$$:  619-block  0
        -:  620:{
    #####:  621:    rp->rio_fd = fd;  
    #####:  622:    rp->rio_cnt = 0;  
    #####:  623:    rp->rio_bufptr = rp->rio_buf;
    #####:  624:}
        -:  625:/* $end rio_readinitb */
        -:  626:
        -:  627:/*
        -:  628: * rio_readnb - Robustly read n bytes (buffered)
        -:  629: */
        -:  630:/* $begin rio_readnb */
function rio_readnb called 0 returned 0% blocks executed 0%
    #####:  631:ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n) 
    $$$$$:  631-block  0
        -:  632:{
    #####:  633:    size_t nleft = n;
        -:  634:    ssize_t nread;
    #####:  635:    char *bufp = usrbuf;
        -:  636:    
    #####:  637:    while (nleft > 0) {
    $$$$$:  637-block  0
    $$$$$:  637-block  1
branch  0 never executed
branch  1 never executed
    #####:  638:        if ((nread = rio_read(rp, bufp, nleft)) < 0) {
    $$$$$:  638-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  639:            if (errno == EINTR) /* interrupted by sig handler return */
    $$$$$:  639-block  0
branch  0 never executed
branch  1 never executed
    #####:  640:                nread = 0;      /* call read() again */
    $$$$$:  640-block  0
        -:  641:            else
    #####:  642:                return -1;      /* errno set by read() */ 
    $$$$$:  642-block  0
        -:  643:        } 
    #####:  644:        else if (nread == 0)
    $$$$$:  644-block  0
branch  0 never executed
branch  1 never executed
    #####:  645:            break;              /* EOF */
    $$$$$:  645-block  0
    #####:  646:        nleft -= nread;
    #####:  647:        bufp += nread;
    $$$$$:  647-block  0
        -:  648:    }
    #####:  649:    return (n - nleft);         /* return >= 0 */
    $$$$$:  649-block  0
        -:  650:}
        -:  651:/* $end rio_readnb */
        -:  652:
        -:  653:/* 
        -:  654: * rio_readlineb - robustly read a text line (buffered)
        -:  655: */
        -:  656:/* $begin rio_readlineb */
function rio_readlineb called 0 returned 0% blocks executed 0%
    #####:  657:ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) 
    $$$$$:  657-block  0
        -:  658:{
        -:  659:    int n, rc;
    #####:  660:    char c, *bufp = usrbuf;
        -:  661:
    #####:  662:    for (n = 1; n < maxlen; n++) { 
    $$$$$:  662-block  0
    $$$$$:  662-block  1
    $$$$$:  662-block  2
branch  0 never executed
branch  1 never executed
    #####:  663:        if ((rc = rio_read(rp, &c, 1)) == 1) {
    $$$$$:  663-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  664:            *bufp++ = c;
    #####:  665:            if (c == '\n')
    $$$$$:  665-block  0
branch  0 never executed
branch  1 never executed
    #####:  666:                break;
    $$$$$:  666-block  0
    #####:  667:        } else if (rc == 0) {
    $$$$$:  667-block  0
branch  0 never executed
branch  1 never executed
    #####:  668:            if (n == 1)
    $$$$$:  668-block  0
branch  0 never executed
branch  1 never executed
    #####:  669:                return 0; /* EOF, no data read */
    $$$$$:  669-block  0
        -:  670:            else
    #####:  671:                break;    /* EOF, some data was read */
    $$$$$:  671-block  0
        -:  672:        } else
    #####:  673:            return -1;    /* error */
    $$$$$:  673-block  0
        -:  674:    }
    #####:  675:    *bufp = 0;
    #####:  676:    return n;
    $$$$$:  676-block  0
    $$$$$:  676-block  1
        -:  677:}
        -:  678:/* $end rio_readlineb */
        -:  679:
        -:  680:/**********************************
        -:  681: * Wrappers for robust I/O routines
        -:  682: **********************************/
function Rio_readn called 0 returned 0% blocks executed 0%
    #####:  683:ssize_t Rio_readn(int fd, void *ptr, size_t nbytes) 
    $$$$$:  683-block  0
        -:  684:{
        -:  685:    ssize_t n;
        -:  686:  
    #####:  687:    if ((n = rio_readn(fd, ptr, nbytes)) < 0)
    $$$$$:  687-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  688:    unix_error("Rio_readn error");
    $$$$$:  688-block  0
call    0 never executed
    #####:  689:    return n;
    $$$$$:  689-block  0
        -:  690:}
        -:  691:
function Rio_writen called 0 returned 0% blocks executed 0%
    #####:  692:void Rio_writen(int fd, void *usrbuf, size_t n) 
    $$$$$:  692-block  0
        -:  693:{
    #####:  694:    if (rio_writen(fd, usrbuf, n) != n)
    $$$$$:  694-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  695:        unix_error("Rio_writen error");
    $$$$$:  695-block  0
call    0 never executed
    #####:  696:}
        -:  697:
function Rio_readinitb called 0 returned 0% blocks executed 0%
    #####:  698:void Rio_readinitb(rio_t *rp, int fd)
    $$$$$:  698-block  0
        -:  699:{
    #####:  700:    rio_readinitb(rp, fd);
    $$$$$:  700-block  0
call    0 never executed
    #####:  701:} 
        -:  702:
function Rio_readnb called 0 returned 0% blocks executed 0%
    #####:  703:ssize_t Rio_readnb(rio_t *rp, void *usrbuf, size_t n) 
    $$$$$:  703-block  0
        -:  704:{
        -:  705:    ssize_t rc;
        -:  706:
    #####:  707:    if ((rc = rio_readnb(rp, usrbuf, n)) < 0)
    $$$$$:  707-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  708:    unix_error("Rio_readnb error");
    $$$$$:  708-block  0
call    0 never executed
    #####:  709:    return rc;
    $$$$$:  709-block  0
        -:  710:}
        -:  711:
function Rio_readlineb called 0 returned 0% blocks executed 0%
    #####:  712:ssize_t Rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) 
    $$$$$:  712-block  0
        -:  713:{
        -:  714:    ssize_t rc;
        -:  715:
    #####:  716:    if ((rc = rio_readlineb(rp, usrbuf, maxlen)) < 0)
    $$$$$:  716-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  717:    unix_error("Rio_readlineb error");
    $$$$$:  717-block  0
call    0 never executed
    #####:  718:    return rc;
    $$$$$:  718-block  0
        -:  719:} 
        -:  720:
        -:  721:/******************************** 
        -:  722: * Client/server helper functions
        -:  723: ********************************/
        -:  724:/*
        -:  725: * open_clientfd - open connection to server at <hostname, port> 
        -:  726: *   and return a socket descriptor ready for reading and writing.
        -:  727: *   Returns -1 and sets errno on Unix error. 
        -:  728: *   Returns -2 and sets h_errno on DNS (gethostbyname) error.
        -:  729: */
        -:  730:/* $begin open_clientfd */
function open_clientfd called 0 returned 0% blocks executed 0%
    #####:  731:int open_clientfd(char *hostname, int port) 
    $$$$$:  731-block  0
        -:  732:{
        -:  733:    int clientfd;
        -:  734:    struct hostent *hp;
        -:  735:    struct sockaddr_in serveraddr;
        -:  736:
    #####:  737:    if ((clientfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    $$$$$:  737-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  738:    return -1; /* check errno for cause of error */
    $$$$$:  738-block  0
        -:  739:
        -:  740:    /* Fill in the server's IP address and port */
    #####:  741:    if ((hp = gethostbyname(hostname)) == NULL)
    $$$$$:  741-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  742:    return -2; /* check h_errno for cause of error */
    $$$$$:  742-block  0
    #####:  743:    bzero((char *) &serveraddr, sizeof(serveraddr));
    #####:  744:    serveraddr.sin_family = AF_INET;
    #####:  745:    bcopy((char *)hp->h_addr_list[0], 
    #####:  746:      (char *)&serveraddr.sin_addr.s_addr, hp->h_length);
    #####:  747:    serveraddr.sin_port = htons(port);
        -:  748:
        -:  749:    /* Establish a connection with the server */
    #####:  750:    if (connect(clientfd, (SA *) &serveraddr, sizeof(serveraddr)) < 0)
    $$$$$:  750-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  751:    return -1;
    $$$$$:  751-block  0
    #####:  752:    return clientfd;
    $$$$$:  752-block  0
    $$$$$:  752-block  1
        -:  753:}
        -:  754:/* $end open_clientfd */
        -:  755:
        -:  756:/*  
        -:  757: * open_listenfd - open and return a listening socket on port
        -:  758: *     Returns -1 and sets errno on Unix error.
        -:  759: */
        -:  760:/* $begin open_listenfd */
function open_listenfd called 1 returned 100% blocks executed 73%
        1:  761:int open_listenfd(int port) 
        1:  761-block  0
        -:  762:{
        1:  763:    int listenfd, optval=1;
        -:  764:    struct sockaddr_in serveraddr;
        -:  765:  
        -:  766:    /* Create a socket descriptor */
        1:  767:    if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
        1:  767-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  768:    return -1;
    $$$$$:  768-block  0
        -:  769: 
        -:  770:    /* Eliminates "Address already in use" error from bind. */
        1:  771:    if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, 
        1:  771-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
        -:  772:           (const void *)&optval , sizeof(int)) < 0)
    #####:  773:    return -1;
    $$$$$:  773-block  0
        -:  774:
        -:  775:    /* Listenfd will be an endpoint for all requests to port
        -:  776:       on any IP address for this host */
        1:  777:    bzero((char *) &serveraddr, sizeof(serveraddr));
        1:  778:    serveraddr.sin_family = AF_INET; 
        1:  779:    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); 
        1:  780:    serveraddr.sin_port = htons((unsigned short)port); 
        1:  781:    if (bind(listenfd, (SA *)&serveraddr, sizeof(serveraddr)) < 0)
        1:  781-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  782:    return -1;
    $$$$$:  782-block  0
        -:  783:
        -:  784:    /* Make it a listening socket ready to accept connection requests */
        1:  785:    if (listen(listenfd, LISTENQ) < 0)
        1:  785-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  786:    return -1;
    $$$$$:  786-block  0
        1:  787:    return listenfd;
        1:  787-block  0
        1:  787-block  1
        -:  788:}
        -:  789:/* $end open_listenfd */
        -:  790:
        -:  791:/******************************************
        -:  792: * Wrappers for the client/server helper routines 
        -:  793: ******************************************/
function Open_clientfd called 0 returned 0% blocks executed 0%
    #####:  794:int Open_clientfd(char *hostname, int port) 
    $$$$$:  794-block  0
        -:  795:{
        -:  796:    int rc;
        -:  797:
    #####:  798:    if ((rc = open_clientfd(hostname, port)) < 0) {
    $$$$$:  798-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  799:        if (rc == -1)
    $$$$$:  799-block  0
branch  0 never executed
branch  1 never executed
    #####:  800:            unix_error("Open_clientfd Unix error");
    $$$$$:  800-block  0
call    0 never executed
        -:  801:        else        
    #####:  802:            dns_error("Open_clientfd DNS error");
    $$$$$:  802-block  0
call    0 never executed
        -:  803:    }
    #####:  804:    return rc;
    $$$$$:  804-block  0
        -:  805:}
        -:  806:
function Open_listenfd called 1 returned 100% blocks executed 80%
        1:  807:int Open_listenfd(int port) 
        1:  807-block  0
        -:  808:{
        -:  809:    int rc;
        -:  810:
        1:  811:    if ((rc = open_listenfd(port)) < 0)
        1:  811-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  812:        unix_error("Open_listenfd error");
    $$$$$:  812-block  0
call    0 never executed
        1:  813:    return rc;
        1:  813-block  0
        -:  814:}
        -:  815:/* $end csapp.c */
        -:  816:
