
## 优先级队列
    全序与偏序
    优先级队列满足偏序即可
    call-by-priority按优先级访问
    优先级队列的特例:
        stack queue严格按照次序作为优先级
        
### 其他数据结构无法实现的原因
    vector sorted-vector list sorted-list各操作insert delmax getmax单个操作最好可能为O(1)但最坏为O(n)
    BBST 各操作基本维持在O(log n)但实现复杂 且性能过剩
### 物理视角
    vector存储,线性存储
### 逻辑视角
    完全二叉树,半线性操作
### 性质
    结构性: 完全二叉树的形态结构
    堆序性: parent > max (lChild, rChild)
### 完全二叉堆性质维护
#### 插入: 
        在树结构的最底层的最右端插入(vector的尾部) 结构性不变 可能破坏堆序性 需要自底向上检查堆序性并维护 直到树的顶端(vecto
    [0])终止 此操作成为上滤 percolateUp
#### 删除: 
        由于树的堆序性 因此每次删除都是删除优先级最高的元素堆顶(vector[0]) 因此删除后 堆序性 保持不变但是破坏了 结构性 需要用
    树最后的节点(vector[n-1])替换堆顶节点vector[0] 替换后可能破坏堆序性 因此向下检查 直到树的最底层终止 此操作成为下滤
    percolateDown
#### 上滤与下滤的区别:
    上滤维护堆序性 每次只需要跟父节点比较1次 需要比较次数为高度h 分摊效率为O(log n) 
    下滤维护堆序性 每次需要跟左右孩子比较2次 需要比较次数为高度h 分摊效率为O(log n)

