
## 策略模式 ##
    
    继承的问题在于对基类的修改会影响所有派生类
    继承的优势在于对代码的复用
    
    定义了算法簇，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
    面向接口编程 组合+接口

    定义策略(算法)接口,对策略接口按照不同的方式实例化,按需将同一个策略接口的不同实现绑定在不同的对象上,也可以将不同的策略接口在新接口中进行组合.最终对新接口再次实例化绑定不同的行为.

## 观察者模式 ##

+ 基本定义

    1:n n依赖1的数据 松耦合(降低对象间的依赖),定义了对象之间的一对多依赖,当一个对象改变状态时,其他所有依赖者都会收到通知并自动更新。

    消息传递机制

    支持广播通信 

+ 实现方式

    推拉模型1->n 
    
    推(1一次性推所有数据给n) 
    
    拉(n分别按需从1获取数据)

+ 实例

    MVC


+ [观察者模式和发布订阅模式区别](https://juejin.im/post/5a14e9edf265da4312808d86)
    

## 迭代器模式 ##
    提供一种方法顺序访问一个聚合对象中的各个元素而又不暴露其内部的表示

    封装变化(遍历)

    面向接口编程与实现解耦(迭代器接口 集合接口)

+ 实例

    STL中各种容器的迭代器实现

    redis中数据结构的迭代器实现

## 命令模式

    http://gameprogrammingpatterns.com/contents.html

    https://www.jianshu.com/p/e236ac5fbd32
    
    https://blog.csdn.net/letthinking/article/details/53068454

    命令就是一个具象化（reified）的方法调用

    命令就是面向对象形式的回调

    绑定执行对象到命令对象

    封装调用 解除行为请求者和行为实现者的紧耦合关系 通过存储命令对象来实现 
    
    命令对象作为中间层解除紧耦合关系 

## 职责链模式

    请求以后，从第一个对象开始，链中收到请求的对象要么亲自处理它，要么转发给链中的下一个候选者。提交请求的对象并不明确知道哪一个对象将会处理它——也就是该请求有一个隐式的接受者（implicit receiver）。根据运行时刻，任一候选者都可以响应相应的请求，候选者的数目是任意的，你可以在运行时刻决定哪些候选者参与到链中。


+ 应用

    nginx中的filter

## 状态模式

    对象在不同的状态时表现不同的行为

    在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。

    https://www.cnblogs.com/nnn123/p/6723729.html
    https://blog.csdn.net/poem_qianmo/article/details/52824776

+ 应用

    游戏手柄的操作 不同状态下 同一个按键可能引起不同的行为

## 模板方法模式

    提供算法框架(模板方法),但算法步骤(基本方法-抽象方法)可进行自定义,也可以抽取出公共(基本方法-共享方法)的默认实现

    https://www.cnblogs.com/wangkaihua/p/9123171.html#autoid-1-0-0