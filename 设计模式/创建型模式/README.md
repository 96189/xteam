
## 单例模式 ##

+ 用途

    全局资源的唯一性和全局访问点

    * 为什么不能用全局变量替代

        全局变量只能提供全局访问并不保证只有一个实例,全局变量生命周期跟随进程,不能做到按需生成

+ 应用 
    
    线程池 连接池 缓存池 数据库连接 日志对象 配置对象等模块

## 工厂模式 ##
    针对接口编程可以隔离以后系统可能发生的一大堆改变,基类指针加多态调用。
+ 简单工厂模式 

    https://testerhome.com/topics/4687

    只有一个工厂且该工厂为静态方法工厂

    优: 分离的对象的创建和使用 使用者只需要传参 不关心具体的产品创建

    缺: 新添加产品 需要修改工厂逻辑

+ 工厂方法模式 

    提供一个工厂的接口 由具体的工厂去实现接口 有多少具体的工厂就存在多少具体的产品 所有产品实现产品的接口
    
    简单工厂模式的问题在于只有一个工厂,添加产品需要改动该工厂的内部逻辑.
    
    工厂方法模式的引进由于客户端操作的是工厂的接口 因此只需要添加对应的产品和工厂即可 对外的接口可以保持不变

    工厂方法多了一个工厂的接口类

    简单工厂模式 客户端使用需要提供类型参数

    工厂方法模式 客户端使用需要知道用到的具体工厂

+ 抽象工厂模式 

    http://www.cnblogs.com/tangyikejun/p/4307887.html
    
    https://blog.csdn.net/longronglin/article/details/1454315

    * 术语与基本概念
        
        产品族  横向-不同产品的组合
        
        产品等级结构  纵向-继承自同一个抽象产品接口的多个产品(类型相同)

        抽象工厂 - 确定工厂的业务范围 - 提供接口给客户端使用
        
        具体工厂 - 是一个产品族
        
        抽象产品 - 抽象产品接口类
        
        具体产品 - 继承抽象产品 实例化

        抽象工厂限定了业务范围(产品族),只能生产产品族以内的产品

    * 以国际化为实例
    
        抽象工厂 - 提供语言Text和语音Voice两个接口(业务范围)
        
        具体工厂 - 中文工厂(Chinese) 英文工厂(English)
        
        抽象产品 - 语言Text 语音Voice
        
        具体产品 - 国际化-中文 国际化-英文

    * 工厂方法模式和抽象工厂模式对比

        工厂方法模式 客户端应用时需要知道自己操作的具体工厂 工厂中只能生成一类产品 工厂类定义时就限制具体的产品类型 即只能在该类型下扩充产品

        抽象工厂模式 客户端应用时同样需要知道自己操作的具体工厂 工厂可生产多类产品(多个产品族) 工厂类定义时限制了业务范围 即可根据该范围组合多个产品族

    * 抽象工厂模式的问题  抽象工厂确定了业务范围(产品等级结构) 改变业务范围(增删产品等级结构)会很麻烦

## 建造者模式

+   定义描述

    某一产品或者对象Product是由各个部件构成的,每一个部件的建造都有相应的接口Builder,具体的建造动作由ConcreteBuiler实现Builder的接口.最终由外部的Director提供对象构建的接口,接口内部可实现各个部件的建造顺序.(因此Builder作为接口参数传递给Director)

+   实例

    游戏角色设计

## 原型模式

    制定种类 创建对象

+ 实例

    游戏中各种不同类型怪物的生成

    protobuf反射机制
