
## 进程资源限制查询与更改
系统命令ulimit -a
getrlimit()
setrlimit()

## 存储空间布局
    high_addr | stack -> ... -> heap -> bss -> data -> text | low_addr

## fork()
### 理论上:
    子进程拷贝父进程内存映像 子进程获得父进程的数据空间、堆和栈 父子进程共享正文段
### 实际上:
    写时拷贝技术(COW)将父进程的内存空间与子进程共享 将访问权限标记为只读 直到父子进程有写操作发生 则将被写的区域已页page
为单位拷贝一份给子进程(COW是以页为单位的)

### 父子进程文件共享:
    注意此处的文件描述符包括socket套接字
    父进程打开的文件描述符保存在父进程的pcb中,fork()会将父进程pcb中的一些信息复制到子进程的pcb中.两个文件描述符对应同一个底
层文件对象,由于文件偏移量在底层文件对象内,因此父子进程共享文件偏移量.父子进程如何一个对文件的写操作更新文件偏移量,都会反应到另一个进程上.

#### 父子进程文件共享的应用:
    nginx master->slaves模型 master父进程监听(ip,80)端点 fork多个子进程 所有子进程共享该端点
    父子进程通信 父进程创建管道 父子进程分别关掉自己不适用的管道一端 避免造成数据混写错误

### 父子进程其他共享的资源
    资源限制、连接的共享存储段、信号屏蔽等
    子进程继承父进程的信号处理方式 因为子进程在开始时复制父进程内存映像 信号捕捉函数的地址在子进程种是有意义的

### 父子进程非共享的资源
    子进程不继承父进程设置的文件锁 子进程未处理闹钟被清除 子进程未处理的信号集设置为空

### fork的应用
    一个进程要执行一个不同的程序,fork完后随即执行exec
    网络应用程序中 子进程复制父进程 然后各自执行不同的代码段 父进程接受连接 子进程处理连接

## wait和waitpid
    当进程正常或者异常终止时,内核就向其父进程发送SIGCHLD信号,由于子进程终止是异步事件,因此该信号由内核异步通知给父进程,父进
程的选择是忽略该信号或者执行信号处理函数处理.

### 调用wait或waitpid可能的情况
    如果没有任何子进程 则立即出错返回
    如果所有子进程都在运行 则阻塞
    如果某个子进程已终止 正等待父进程获取其终止状态 则取得该子进程终止状态立即返回
### api
    status存储进程退出时的终止状态
    // 成功返回进程id 出错返回0或-1
    // 等待任意进程终止
    pid_t wait(int *status)
    
    // 等待pid指定的进程终止 
    // pid == -1 等待任意子进程
    // pid > 0 等待指定的子进程
    // pid == 0 等待组id等于调用进程组id的任一子进程
    // pid < -1 等待组id等于pid绝对值的任一子进程 
    // option WHOHANG waitpid不阻塞 即使没有进程终止 WCONTINUED WUNTRACED关于作业控制
    // 返回值
    // 设置WHOHANG选项 返回0 表示没有已退出的子进程可收集
    // 返回-1 调用出错 会设置error
    pid_t waitpid(pid_t pid, int *status, int options)

#### 获取进程退出原因
    wait或者waitpid函数退出后 通过宏测试status可以得到退出原因
    WIFEXITED(status) 为真 正常终止
    WIFSIGNALED(status) 为真 异常终止 WTERMSIG(status)获取使进程异常终止的信号值
    WIFSTOPPED(status) 为真 暂停子进程 WSTOPGIG(status)获得使子进程暂停的信号值
    WIFCONTINUED(status) 为真 暂停后已经继续的子进程返回

#### 应用实例
    ngx_process_get_status() { pid = waitpid(-1, &status, WNOHANG) }

    